{"ast":null,"code":"require(\"core-js/modules/es.regexp.exec.js\");\n\nrequire(\"core-js/modules/es.array.concat.js\");\n\nrequire(\"core-js/modules/es.array.map.js\");\n\nrequire(\"core-js/modules/es.array.sort.js\");\n\nrequire(\"core-js/modules/es.object.to-string.js\");\n\nrequire(\"core-js/modules/es.error.cause.js\");\n\nrequire(\"core-js/modules/es.regexp.to-string.js\");\n\nvar Mode = require('./mode');\n\nvar NumericData = require('./numeric-data');\n\nvar AlphanumericData = require('./alphanumeric-data');\n\nvar ByteData = require('./byte-data');\n\nvar KanjiData = require('./kanji-data');\n\nvar Regex = require('./regex');\n\nvar Utils = require('./utils');\n\nvar dijkstra = require('dijkstrajs');\n/**\r\n * Returns UTF8 byte length\r\n *\r\n * @param  {String} str Input string\r\n * @return {Number}     Number of byte\r\n */\n\n\nfunction getStringByteLength(str) {\n  return unescape(encodeURIComponent(str)).length;\n}\n/**\r\n * Get a list of segments of the specified mode\r\n * from a string\r\n *\r\n * @param  {Mode}   mode Segment mode\r\n * @param  {String} str  String to process\r\n * @return {Array}       Array of object with segments data\r\n */\n\n\nfunction getSegments(regex, mode, str) {\n  var segments = [];\n  var result;\n\n  while ((result = regex.exec(str)) !== null) {\n    segments.push({\n      data: result[0],\n      index: result.index,\n      mode: mode,\n      length: result[0].length\n    });\n  }\n\n  return segments;\n}\n/**\r\n * Extracts a series of segments with the appropriate\r\n * modes from a string\r\n *\r\n * @param  {String} dataStr Input string\r\n * @return {Array}          Array of object with segments data\r\n */\n\n\nfunction getSegmentsFromString(dataStr) {\n  var numSegs = getSegments(Regex.NUMERIC, Mode.NUMERIC, dataStr);\n  var alphaNumSegs = getSegments(Regex.ALPHANUMERIC, Mode.ALPHANUMERIC, dataStr);\n  var byteSegs;\n  var kanjiSegs;\n\n  if (Utils.isKanjiModeEnabled()) {\n    byteSegs = getSegments(Regex.BYTE, Mode.BYTE, dataStr);\n    kanjiSegs = getSegments(Regex.KANJI, Mode.KANJI, dataStr);\n  } else {\n    byteSegs = getSegments(Regex.BYTE_KANJI, Mode.BYTE, dataStr);\n    kanjiSegs = [];\n  }\n\n  var segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs);\n  return segs.sort(function (s1, s2) {\n    return s1.index - s2.index;\n  }).map(function (obj) {\n    return {\n      data: obj.data,\n      mode: obj.mode,\n      length: obj.length\n    };\n  });\n}\n/**\r\n * Returns how many bits are needed to encode a string of\r\n * specified length with the specified mode\r\n *\r\n * @param  {Number} length String length\r\n * @param  {Mode} mode     Segment mode\r\n * @return {Number}        Bit length\r\n */\n\n\nfunction getSegmentBitsLength(length, mode) {\n  switch (mode) {\n    case Mode.NUMERIC:\n      return NumericData.getBitsLength(length);\n\n    case Mode.ALPHANUMERIC:\n      return AlphanumericData.getBitsLength(length);\n\n    case Mode.KANJI:\n      return KanjiData.getBitsLength(length);\n\n    case Mode.BYTE:\n      return ByteData.getBitsLength(length);\n  }\n}\n/**\r\n * Merges adjacent segments which have the same mode\r\n *\r\n * @param  {Array} segs Array of object with segments data\r\n * @return {Array}      Array of object with segments data\r\n */\n\n\nfunction mergeSegments(segs) {\n  return segs.reduce(function (acc, curr) {\n    var prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null;\n\n    if (prevSeg && prevSeg.mode === curr.mode) {\n      acc[acc.length - 1].data += curr.data;\n      return acc;\n    }\n\n    acc.push(curr);\n    return acc;\n  }, []);\n}\n/**\r\n * Generates a list of all possible nodes combination which\r\n * will be used to build a segments graph.\r\n *\r\n * Nodes are divided by groups. Each group will contain a list of all the modes\r\n * in which is possible to encode the given text.\r\n *\r\n * For example the text '12345' can be encoded as Numeric, Alphanumeric or Byte.\r\n * The group for '12345' will contain then 3 objects, one for each\r\n * possible encoding mode.\r\n *\r\n * Each node represents a possible segment.\r\n *\r\n * @param  {Array} segs Array of object with segments data\r\n * @return {Array}      Array of object with segments data\r\n */\n\n\nfunction buildNodes(segs) {\n  var nodes = [];\n\n  for (var i = 0; i < segs.length; i++) {\n    var seg = segs[i];\n\n    switch (seg.mode) {\n      case Mode.NUMERIC:\n        nodes.push([seg, {\n          data: seg.data,\n          mode: Mode.ALPHANUMERIC,\n          length: seg.length\n        }, {\n          data: seg.data,\n          mode: Mode.BYTE,\n          length: seg.length\n        }]);\n        break;\n\n      case Mode.ALPHANUMERIC:\n        nodes.push([seg, {\n          data: seg.data,\n          mode: Mode.BYTE,\n          length: seg.length\n        }]);\n        break;\n\n      case Mode.KANJI:\n        nodes.push([seg, {\n          data: seg.data,\n          mode: Mode.BYTE,\n          length: getStringByteLength(seg.data)\n        }]);\n        break;\n\n      case Mode.BYTE:\n        nodes.push([{\n          data: seg.data,\n          mode: Mode.BYTE,\n          length: getStringByteLength(seg.data)\n        }]);\n    }\n  }\n\n  return nodes;\n}\n/**\r\n * Builds a graph from a list of nodes.\r\n * All segments in each node group will be connected with all the segments of\r\n * the next group and so on.\r\n *\r\n * At each connection will be assigned a weight depending on the\r\n * segment's byte length.\r\n *\r\n * @param  {Array} nodes    Array of object with segments data\r\n * @param  {Number} version QR Code version\r\n * @return {Object}         Graph of all possible segments\r\n */\n\n\nfunction buildGraph(nodes, version) {\n  var table = {};\n  var graph = {\n    start: {}\n  };\n  var prevNodeIds = ['start'];\n\n  for (var i = 0; i < nodes.length; i++) {\n    var nodeGroup = nodes[i];\n    var currentNodeIds = [];\n\n    for (var j = 0; j < nodeGroup.length; j++) {\n      var node = nodeGroup[j];\n      var key = '' + i + j;\n      currentNodeIds.push(key);\n      table[key] = {\n        node: node,\n        lastCount: 0\n      };\n      graph[key] = {};\n\n      for (var n = 0; n < prevNodeIds.length; n++) {\n        var prevNodeId = prevNodeIds[n];\n\n        if (table[prevNodeId] && table[prevNodeId].node.mode === node.mode) {\n          graph[prevNodeId][key] = getSegmentBitsLength(table[prevNodeId].lastCount + node.length, node.mode) - getSegmentBitsLength(table[prevNodeId].lastCount, node.mode);\n          table[prevNodeId].lastCount += node.length;\n        } else {\n          if (table[prevNodeId]) table[prevNodeId].lastCount = node.length;\n          graph[prevNodeId][key] = getSegmentBitsLength(node.length, node.mode) + 4 + Mode.getCharCountIndicator(node.mode, version); // switch cost\n        }\n      }\n    }\n\n    prevNodeIds = currentNodeIds;\n  }\n\n  for (var _n = 0; _n < prevNodeIds.length; _n++) {\n    graph[prevNodeIds[_n]].end = 0;\n  }\n\n  return {\n    map: graph,\n    table: table\n  };\n}\n/**\r\n * Builds a segment from a specified data and mode.\r\n * If a mode is not specified, the more suitable will be used.\r\n *\r\n * @param  {String} data             Input data\r\n * @param  {Mode | String} modesHint Data mode\r\n * @return {Segment}                 Segment\r\n */\n\n\nfunction buildSingleSegment(data, modesHint) {\n  var mode;\n  var bestMode = Mode.getBestModeForData(data);\n  mode = Mode.from(modesHint, bestMode); // Make sure data can be encoded\n\n  if (mode !== Mode.BYTE && mode.bit < bestMode.bit) {\n    throw new Error('\"' + data + '\"' + ' cannot be encoded with mode ' + Mode.toString(mode) + '.\\n Suggested mode is: ' + Mode.toString(bestMode));\n  } // Use Mode.BYTE if Kanji support is disabled\n\n\n  if (mode === Mode.KANJI && !Utils.isKanjiModeEnabled()) {\n    mode = Mode.BYTE;\n  }\n\n  switch (mode) {\n    case Mode.NUMERIC:\n      return new NumericData(data);\n\n    case Mode.ALPHANUMERIC:\n      return new AlphanumericData(data);\n\n    case Mode.KANJI:\n      return new KanjiData(data);\n\n    case Mode.BYTE:\n      return new ByteData(data);\n  }\n}\n/**\r\n * Builds a list of segments from an array.\r\n * Array can contain Strings or Objects with segment's info.\r\n *\r\n * For each item which is a string, will be generated a segment with the given\r\n * string and the more appropriate encoding mode.\r\n *\r\n * For each item which is an object, will be generated a segment with the given\r\n * data and mode.\r\n * Objects must contain at least the property \"data\".\r\n * If property \"mode\" is not present, the more suitable mode will be used.\r\n *\r\n * @param  {Array} array Array of objects with segments data\r\n * @return {Array}       Array of Segments\r\n */\n\n\nexports.fromArray = function fromArray(array) {\n  return array.reduce(function (acc, seg) {\n    if (typeof seg === 'string') {\n      acc.push(buildSingleSegment(seg, null));\n    } else if (seg.data) {\n      acc.push(buildSingleSegment(seg.data, seg.mode));\n    }\n\n    return acc;\n  }, []);\n};\n/**\r\n * Builds an optimized sequence of segments from a string,\r\n * which will produce the shortest possible bitstream.\r\n *\r\n * @param  {String} data    Input string\r\n * @param  {Number} version QR Code version\r\n * @return {Array}          Array of segments\r\n */\n\n\nexports.fromString = function fromString(data, version) {\n  var segs = getSegmentsFromString(data, Utils.isKanjiModeEnabled());\n  var nodes = buildNodes(segs);\n  var graph = buildGraph(nodes, version);\n  var path = dijkstra.find_path(graph.map, 'start', 'end');\n  var optimizedSegs = [];\n\n  for (var i = 1; i < path.length - 1; i++) {\n    optimizedSegs.push(graph.table[path[i]].node);\n  }\n\n  return exports.fromArray(mergeSegments(optimizedSegs));\n};\n/**\r\n * Splits a string in various segments with the modes which\r\n * best represent their content.\r\n * The produced segments are far from being optimized.\r\n * The output of this function is only used to estimate a QR Code version\r\n * which may contain the data.\r\n *\r\n * @param  {string} data Input string\r\n * @return {Array}       Array of segments\r\n */\n\n\nexports.rawSplit = function rawSplit(data) {\n  return exports.fromArray(getSegmentsFromString(data, Utils.isKanjiModeEnabled()));\n};","map":{"version":3,"sources":["C:/Users/asus/Desktop/新建文件夹/SPH-zp/node_modules/qrcode/lib/core/segments.js"],"names":["Mode","require","NumericData","AlphanumericData","ByteData","KanjiData","Regex","Utils","dijkstra","getStringByteLength","str","unescape","encodeURIComponent","length","getSegments","regex","mode","segments","result","exec","push","data","index","getSegmentsFromString","dataStr","numSegs","NUMERIC","alphaNumSegs","ALPHANUMERIC","byteSegs","kanjiSegs","isKanjiModeEnabled","BYTE","KANJI","BYTE_KANJI","segs","concat","sort","s1","s2","map","obj","getSegmentBitsLength","getBitsLength","mergeSegments","reduce","acc","curr","prevSeg","buildNodes","nodes","i","seg","buildGraph","version","table","graph","start","prevNodeIds","nodeGroup","currentNodeIds","j","node","key","lastCount","n","prevNodeId","getCharCountIndicator","end","buildSingleSegment","modesHint","bestMode","getBestModeForData","from","bit","Error","toString","exports","fromArray","array","fromString","path","find_path","optimizedSegs","rawSplit"],"mappings":"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","sourcesContent":["const Mode = require('./mode')\r\nconst NumericData = require('./numeric-data')\r\nconst AlphanumericData = require('./alphanumeric-data')\r\nconst ByteData = require('./byte-data')\r\nconst KanjiData = require('./kanji-data')\r\nconst Regex = require('./regex')\r\nconst Utils = require('./utils')\r\nconst dijkstra = require('dijkstrajs')\r\n\r\n/**\r\n * Returns UTF8 byte length\r\n *\r\n * @param  {String} str Input string\r\n * @return {Number}     Number of byte\r\n */\r\nfunction getStringByteLength (str) {\r\n  return unescape(encodeURIComponent(str)).length\r\n}\r\n\r\n/**\r\n * Get a list of segments of the specified mode\r\n * from a string\r\n *\r\n * @param  {Mode}   mode Segment mode\r\n * @param  {String} str  String to process\r\n * @return {Array}       Array of object with segments data\r\n */\r\nfunction getSegments (regex, mode, str) {\r\n  const segments = []\r\n  let result\r\n\r\n  while ((result = regex.exec(str)) !== null) {\r\n    segments.push({\r\n      data: result[0],\r\n      index: result.index,\r\n      mode: mode,\r\n      length: result[0].length\r\n    })\r\n  }\r\n\r\n  return segments\r\n}\r\n\r\n/**\r\n * Extracts a series of segments with the appropriate\r\n * modes from a string\r\n *\r\n * @param  {String} dataStr Input string\r\n * @return {Array}          Array of object with segments data\r\n */\r\nfunction getSegmentsFromString (dataStr) {\r\n  const numSegs = getSegments(Regex.NUMERIC, Mode.NUMERIC, dataStr)\r\n  const alphaNumSegs = getSegments(Regex.ALPHANUMERIC, Mode.ALPHANUMERIC, dataStr)\r\n  let byteSegs\r\n  let kanjiSegs\r\n\r\n  if (Utils.isKanjiModeEnabled()) {\r\n    byteSegs = getSegments(Regex.BYTE, Mode.BYTE, dataStr)\r\n    kanjiSegs = getSegments(Regex.KANJI, Mode.KANJI, dataStr)\r\n  } else {\r\n    byteSegs = getSegments(Regex.BYTE_KANJI, Mode.BYTE, dataStr)\r\n    kanjiSegs = []\r\n  }\r\n\r\n  const segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs)\r\n\r\n  return segs\r\n    .sort(function (s1, s2) {\r\n      return s1.index - s2.index\r\n    })\r\n    .map(function (obj) {\r\n      return {\r\n        data: obj.data,\r\n        mode: obj.mode,\r\n        length: obj.length\r\n      }\r\n    })\r\n}\r\n\r\n/**\r\n * Returns how many bits are needed to encode a string of\r\n * specified length with the specified mode\r\n *\r\n * @param  {Number} length String length\r\n * @param  {Mode} mode     Segment mode\r\n * @return {Number}        Bit length\r\n */\r\nfunction getSegmentBitsLength (length, mode) {\r\n  switch (mode) {\r\n    case Mode.NUMERIC:\r\n      return NumericData.getBitsLength(length)\r\n    case Mode.ALPHANUMERIC:\r\n      return AlphanumericData.getBitsLength(length)\r\n    case Mode.KANJI:\r\n      return KanjiData.getBitsLength(length)\r\n    case Mode.BYTE:\r\n      return ByteData.getBitsLength(length)\r\n  }\r\n}\r\n\r\n/**\r\n * Merges adjacent segments which have the same mode\r\n *\r\n * @param  {Array} segs Array of object with segments data\r\n * @return {Array}      Array of object with segments data\r\n */\r\nfunction mergeSegments (segs) {\r\n  return segs.reduce(function (acc, curr) {\r\n    const prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null\r\n    if (prevSeg && prevSeg.mode === curr.mode) {\r\n      acc[acc.length - 1].data += curr.data\r\n      return acc\r\n    }\r\n\r\n    acc.push(curr)\r\n    return acc\r\n  }, [])\r\n}\r\n\r\n/**\r\n * Generates a list of all possible nodes combination which\r\n * will be used to build a segments graph.\r\n *\r\n * Nodes are divided by groups. Each group will contain a list of all the modes\r\n * in which is possible to encode the given text.\r\n *\r\n * For example the text '12345' can be encoded as Numeric, Alphanumeric or Byte.\r\n * The group for '12345' will contain then 3 objects, one for each\r\n * possible encoding mode.\r\n *\r\n * Each node represents a possible segment.\r\n *\r\n * @param  {Array} segs Array of object with segments data\r\n * @return {Array}      Array of object with segments data\r\n */\r\nfunction buildNodes (segs) {\r\n  const nodes = []\r\n  for (let i = 0; i < segs.length; i++) {\r\n    const seg = segs[i]\r\n\r\n    switch (seg.mode) {\r\n      case Mode.NUMERIC:\r\n        nodes.push([seg,\r\n          { data: seg.data, mode: Mode.ALPHANUMERIC, length: seg.length },\r\n          { data: seg.data, mode: Mode.BYTE, length: seg.length }\r\n        ])\r\n        break\r\n      case Mode.ALPHANUMERIC:\r\n        nodes.push([seg,\r\n          { data: seg.data, mode: Mode.BYTE, length: seg.length }\r\n        ])\r\n        break\r\n      case Mode.KANJI:\r\n        nodes.push([seg,\r\n          { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }\r\n        ])\r\n        break\r\n      case Mode.BYTE:\r\n        nodes.push([\r\n          { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }\r\n        ])\r\n    }\r\n  }\r\n\r\n  return nodes\r\n}\r\n\r\n/**\r\n * Builds a graph from a list of nodes.\r\n * All segments in each node group will be connected with all the segments of\r\n * the next group and so on.\r\n *\r\n * At each connection will be assigned a weight depending on the\r\n * segment's byte length.\r\n *\r\n * @param  {Array} nodes    Array of object with segments data\r\n * @param  {Number} version QR Code version\r\n * @return {Object}         Graph of all possible segments\r\n */\r\nfunction buildGraph (nodes, version) {\r\n  const table = {}\r\n  const graph = { start: {} }\r\n  let prevNodeIds = ['start']\r\n\r\n  for (let i = 0; i < nodes.length; i++) {\r\n    const nodeGroup = nodes[i]\r\n    const currentNodeIds = []\r\n\r\n    for (let j = 0; j < nodeGroup.length; j++) {\r\n      const node = nodeGroup[j]\r\n      const key = '' + i + j\r\n\r\n      currentNodeIds.push(key)\r\n      table[key] = { node: node, lastCount: 0 }\r\n      graph[key] = {}\r\n\r\n      for (let n = 0; n < prevNodeIds.length; n++) {\r\n        const prevNodeId = prevNodeIds[n]\r\n\r\n        if (table[prevNodeId] && table[prevNodeId].node.mode === node.mode) {\r\n          graph[prevNodeId][key] =\r\n            getSegmentBitsLength(table[prevNodeId].lastCount + node.length, node.mode) -\r\n            getSegmentBitsLength(table[prevNodeId].lastCount, node.mode)\r\n\r\n          table[prevNodeId].lastCount += node.length\r\n        } else {\r\n          if (table[prevNodeId]) table[prevNodeId].lastCount = node.length\r\n\r\n          graph[prevNodeId][key] = getSegmentBitsLength(node.length, node.mode) +\r\n            4 + Mode.getCharCountIndicator(node.mode, version) // switch cost\r\n        }\r\n      }\r\n    }\r\n\r\n    prevNodeIds = currentNodeIds\r\n  }\r\n\r\n  for (let n = 0; n < prevNodeIds.length; n++) {\r\n    graph[prevNodeIds[n]].end = 0\r\n  }\r\n\r\n  return { map: graph, table: table }\r\n}\r\n\r\n/**\r\n * Builds a segment from a specified data and mode.\r\n * If a mode is not specified, the more suitable will be used.\r\n *\r\n * @param  {String} data             Input data\r\n * @param  {Mode | String} modesHint Data mode\r\n * @return {Segment}                 Segment\r\n */\r\nfunction buildSingleSegment (data, modesHint) {\r\n  let mode\r\n  const bestMode = Mode.getBestModeForData(data)\r\n\r\n  mode = Mode.from(modesHint, bestMode)\r\n\r\n  // Make sure data can be encoded\r\n  if (mode !== Mode.BYTE && mode.bit < bestMode.bit) {\r\n    throw new Error('\"' + data + '\"' +\r\n      ' cannot be encoded with mode ' + Mode.toString(mode) +\r\n      '.\\n Suggested mode is: ' + Mode.toString(bestMode))\r\n  }\r\n\r\n  // Use Mode.BYTE if Kanji support is disabled\r\n  if (mode === Mode.KANJI && !Utils.isKanjiModeEnabled()) {\r\n    mode = Mode.BYTE\r\n  }\r\n\r\n  switch (mode) {\r\n    case Mode.NUMERIC:\r\n      return new NumericData(data)\r\n\r\n    case Mode.ALPHANUMERIC:\r\n      return new AlphanumericData(data)\r\n\r\n    case Mode.KANJI:\r\n      return new KanjiData(data)\r\n\r\n    case Mode.BYTE:\r\n      return new ByteData(data)\r\n  }\r\n}\r\n\r\n/**\r\n * Builds a list of segments from an array.\r\n * Array can contain Strings or Objects with segment's info.\r\n *\r\n * For each item which is a string, will be generated a segment with the given\r\n * string and the more appropriate encoding mode.\r\n *\r\n * For each item which is an object, will be generated a segment with the given\r\n * data and mode.\r\n * Objects must contain at least the property \"data\".\r\n * If property \"mode\" is not present, the more suitable mode will be used.\r\n *\r\n * @param  {Array} array Array of objects with segments data\r\n * @return {Array}       Array of Segments\r\n */\r\nexports.fromArray = function fromArray (array) {\r\n  return array.reduce(function (acc, seg) {\r\n    if (typeof seg === 'string') {\r\n      acc.push(buildSingleSegment(seg, null))\r\n    } else if (seg.data) {\r\n      acc.push(buildSingleSegment(seg.data, seg.mode))\r\n    }\r\n\r\n    return acc\r\n  }, [])\r\n}\r\n\r\n/**\r\n * Builds an optimized sequence of segments from a string,\r\n * which will produce the shortest possible bitstream.\r\n *\r\n * @param  {String} data    Input string\r\n * @param  {Number} version QR Code version\r\n * @return {Array}          Array of segments\r\n */\r\nexports.fromString = function fromString (data, version) {\r\n  const segs = getSegmentsFromString(data, Utils.isKanjiModeEnabled())\r\n\r\n  const nodes = buildNodes(segs)\r\n  const graph = buildGraph(nodes, version)\r\n  const path = dijkstra.find_path(graph.map, 'start', 'end')\r\n\r\n  const optimizedSegs = []\r\n  for (let i = 1; i < path.length - 1; i++) {\r\n    optimizedSegs.push(graph.table[path[i]].node)\r\n  }\r\n\r\n  return exports.fromArray(mergeSegments(optimizedSegs))\r\n}\r\n\r\n/**\r\n * Splits a string in various segments with the modes which\r\n * best represent their content.\r\n * The produced segments are far from being optimized.\r\n * The output of this function is only used to estimate a QR Code version\r\n * which may contain the data.\r\n *\r\n * @param  {string} data Input string\r\n * @return {Array}       Array of segments\r\n */\r\nexports.rawSplit = function rawSplit (data) {\r\n  return exports.fromArray(\r\n    getSegmentsFromString(data, Utils.isKanjiModeEnabled())\r\n  )\r\n}\r\n"]},"metadata":{},"sourceType":"script"}